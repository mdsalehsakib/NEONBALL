<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Runner Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }
        video { 
            position: absolute; top: 0; left: 0; 
            width: 1px; height: 1px; opacity: 0; pointer-events: none; 
        }

        /* --- HUD --- */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            box-shadow: inset 0 0 30px rgba(0, 255, 255, 0.2);
            z-index: 10;
        }
        .damage-effect { box-shadow: inset 0 0 50px rgba(255, 0, 0, 0.8) !important; background: rgba(255,0,0,0.2); }

        .hud-panel {
            position: absolute;
            padding: 8px 12px; color: #0ff;
            font-size: 12px; font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            backdrop-filter: blur(2px);
        }

        #top-center { 
            top: 10px; left: 50%; transform: translateX(-50%); 
            text-align: center; 
        }
        #score-display { font-size: 24px; color: #fff; display: block; }
        
        #bottom-left { bottom: 20px; left: 20px; }
        
        /* --- BRANDING --- */
        #branding-btn {
            position: absolute; bottom: 20px; right: 20px;
            pointer-events: auto; text-decoration: none;
            color: white; background: rgba(0, 255, 204, 0.2);
            border: 1px solid #00ffcc; padding: 8px 15px;
            border-radius: 20px; font-size: 10px; font-weight: bold;
        }

        /* --- START SCREEN --- */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #fff; z-index: 100; text-align: center;
        }
        
        #start-btn {
            margin-top: 20px; padding: 15px 40px;
            background: #00ffcc; color: #000;
            border: none; font-size: 18px; font-weight: bold;
            border-radius: 30px;
            display: none; /* Hidden until camera ready */
        }

        /* --- TRACKER --- */
        #hand-tracker {
            position: absolute; width: 40px; height: 40px;
            border: 4px solid #ff0055; border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            box-shadow: 0 0 10px #ff0055;
        }
        .pinched { background: rgba(255, 0, 85, 0.5); width: 20px; height: 20px; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <video id="webcam" autoplay playsinline webkit-playsinline muted></video>

    <div id="overlay">
        <h1 style="color:#00ffcc; margin-bottom: 5px;">NEON RUNNER</h1>
        <p id="status" style="font-size: 12px; color: #aaa;">INITIALIZING AI...</p>
        <button id="start-btn">TAP TO START</button>
        <p style="font-size: 10px; color: #666; margin-top: 20px;">Use Chrome or Safari<br>Allow Camera Access</p>
    </div>

    <div id="hud-layer">
        <div id="hand-tracker"></div>

        <div id="top-center" class="hud-panel">
            <span>DISTANCE</span>
            <span id="score-display">0000</span>
        </div>

        <div id="bottom-left" class="hud-panel">
            <div id="warp-status">WARP: READY</div>
        </div>

        <a id="branding-btn" href="https://linktr.ee/salehsakib" target="_blank">
            Made by Md Saleh Sakib
        </a>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONFIG ---
        const MOVEMENT_SENSITIVITY = 60; // Higher = more movement
        const TRACKING_STRENGTH = 0.04; // Obstacle homing strength
        
        let scene, camera, renderer, starMesh;
        let obstacles = [];
        let score = 0;
        let gameSpeed = 1.0;
        let isRunning = false;
        
        // Player
        let playerX = 0;
        let playerY = 0;
        let isPinching = false;

        // Audio
        let audioCtx, engineOsc, engineGain;

        // DOM
        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const scoreEl = document.getElementById('score-display');
        const tracker = document.getElementById('hand-tracker');
        const hud = document.getElementById('hud-layer');
        const video = document.getElementById('webcam');

        // --- 1. SETUP ---
        async function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.003);

            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.z = 5;

            // Renderer (Optimized for Mobile)
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel density
            document.body.appendChild(renderer.domElement);

            createStarField();
            
            // Resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Load AI
            await setupAI();
        }

        function createStarField() {
            const count = 1500; // Lower count for mobile FPS
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) pos[i] = (Math.random()-0.5) * 800;
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ size: 2, color: 0x88ccff });
            starMesh = new THREE.Points(geom, mat);
            scene.add(starMesh);
        }

        // --- 2. GAME LOGIC ---
        function startGame() {
            initAudio();
            isRunning = true;
            score = 0;
            obstacles.forEach(o => scene.remove(o));
            obstacles = [];
            hud.classList.remove('damage-effect');
            overlay.style.display = 'none';
            
            animate();
            spawnLoop();
        }

        function spawnLoop() {
            if(!isRunning) return;
            spawnObstacle();
            // Difficulty curve
            let delay = 1200 - (score * 2);
            if(delay < 400) delay = 400;
            setTimeout(spawnLoop, delay);
        }

        function spawnObstacle() {
            const geom = new THREE.IcosahedronGeometry(2, 0); // Simple shape
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0044, wireframe: true });
            const obs = new THREE.Mesh(geom, mat);
            
            obs.position.z = -400;
            // Spawn near player X/Y to ensure they have to dodge
            obs.position.x = (Math.random() - 0.5) * 60 + camera.position.x * 0.5;
            obs.position.y = (Math.random() - 0.5) * 40 + camera.position.y * 0.5;
            
            scene.add(obs);
            obstacles.push(obs);
        }

        function gameOver() {
            isRunning = false;
            hud.classList.add('damage-effect');
            statusEl.innerText = "GAME OVER - SCORE: " + Math.floor(score);
            startBtn.innerText = "RETRY";
            overlay.style.display = 'flex';
            
            // Mobile vibration
            if(navigator.vibrate) navigator.vibrate(500);
        }

        // --- 3. INPUT (AI) ---
        async function setupAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                const landmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                // Request Camera (Explicitly 'user' facing)
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: "user",
                        width: { ideal: 640 }, // Low res for speed
                        height: { ideal: 480 }
                    },
                    audio: false
                });

                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    statusEl.innerText = "SYSTEM READY";
                    startBtn.style.display = "block";
                    startBtn.onclick = startGame;
                    predictLoop(landmarker);
                });

            } catch(e) {
                statusEl.innerText = "CAMERA ERROR: " + e.message;
            }
        }

        function predictLoop(landmarker) {
            let lastTime = -1;
            const loop = () => {
                if(video.currentTime !== lastTime) {
                    lastTime = video.currentTime;
                    const result = landmarker.detectForVideo(video, performance.now());
                    
                    if(result.landmarks.length > 0) {
                        const hand = result.landmarks[0];
                        const index = hand[8];
                        const thumb = hand[4];

                        // Mobile Mirroring Logic (X is inverted)
                        const x = (1 - index.x); 
                        const y = index.y;

                        // UI Tracker
                        tracker.style.display = 'block';
                        tracker.style.left = (x * 100) + '%';
                        tracker.style.top = (y * 100) + '%';

                        // Player Movement (Center is 0.5)
                        playerX = (x - 0.5) * MOVEMENT_SENSITIVITY;
                        playerY = (0.5 - y) * (MOVEMENT_SENSITIVITY * 0.8); // Less Y range on phones

                        // Pinch (Warp)
                        const dist = Math.hypot(index.x - thumb.x, index.y - thumb.y);
                        isPinching = dist < 0.08;
                        if(isPinching) tracker.classList.add('pinched');
                        else tracker.classList.remove('pinched');

                    } else {
                        tracker.style.display = 'none';
                        isPinching = false;
                        // Auto-center slowly if no hand
                        playerX *= 0.95;
                        playerY *= 0.95;
                    }
                }
                requestAnimationFrame(loop);
            };
            loop();
        }

        // --- 4. AUDIO ---
        function initAudio() {
            if(audioCtx) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            
            engineOsc = audioCtx.createOscillator();
            engineGain = audioCtx.createGain();
            engineOsc.type = 'sawtooth';
            engineOsc.frequency.value = 50;
            engineOsc.connect(engineGain);
            engineGain.connect(audioCtx.destination);
            engineGain.gain.value = 0.05;
            engineOsc.start();
        }

        // --- 5. RENDER LOOP ---
        function animate() {
            if(!isRunning) return;
            requestAnimationFrame(animate);

            // Move Camera
            camera.position.x += (playerX - camera.position.x) * 0.1;
            camera.position.y += (playerY - camera.position.y) * 0.1;
            
            // Banking effect
            camera.rotation.z = (camera.position.x - playerX) * 0.01;

            // Speed
            let targetSpeed = isPinching ? 5.0 : 1.5;
            gameSpeed += (targetSpeed - gameSpeed) * 0.1;
            score += gameSpeed;
            scoreEl.innerText = Math.floor(score).toString().padStart(4, '0');

            // Audio Pitch
            if(engineOsc) engineOsc.frequency.value = 50 + (gameSpeed * 20);

            // Stars
            const stars = starMesh.geometry.attributes.position.array;
            for(let i=2; i<stars.length; i+=3) {
                stars[i] += gameSpeed * 4;
                if(stars[i] > 10) stars[i] = -800;
            }
            starMesh.geometry.attributes.position.needsUpdate = true;

            // Obstacles
            for(let i=obstacles.length-1; i>=0; i--) {
                let obs = obstacles[i];
                obs.position.z += gameSpeed * 6;
                obs.rotation.x += 0.05;
                
                // Homing Logic
                if(obs.position.z < -10) {
                    obs.position.x += (camera.position.x - obs.position.x) * TRACKING_STRENGTH;
                    obs.position.y += (camera.position.y - obs.position.y) * TRACKING_STRENGTH;
                }

                // Collision
                if(obs.position.z > 0 && obs.position.z < 10) {
                    let dist = Math.hypot(obs.position.x - camera.position.x, obs.position.y - camera.position.y);
                    if(dist < 3.5) gameOver();
                }

                if(obs.position.z > 20) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
